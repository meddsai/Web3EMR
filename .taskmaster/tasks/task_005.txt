# Task ID: 5
# Title: Develop Patient Portal UI with React
# Status: pending
# Dependencies: 3, 4
# Priority: medium
# Description: Create a responsive React-based web application for patient interactions with the Web3EMR system.
# Details:
1. Set up React project with TypeScript
2. Implement responsive design for desktop and mobile
3. Create components for EMR management, access control, and history viewing
4. Implement Polkadot.js wallet integration
5. Develop UI for KILT DID creation and management
6. Create interfaces for EMR upload, viewing, and sharing
7. Implement accessibility features (WCAG 2.1 AA compliance)
8. Add offline capabilities for basic functions

Pseudo-code for React components with latest Polkadot.js API:
```typescript
// src/components/EMRManagement.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { ApiPromise, WsProvider } from '@polkadot/api';
import { web3Enable, web3FromSource } from '@polkadot/extension-dapp';
import { keyring } from '@polkadot/ui-keyring';
import { TypeRegistry } from '@polkadot/types/create';
import { formatBalance } from '@polkadot/util';

// Configure format balance options
const formatBalanceOptions = {
  decimals: 12, // Adjust based on your chain's token decimals
  withUnit: 'UNIT', // Your chain's token symbol
  withSi: true,
};

interface EMR {
  id: string;
  name: string;
  date: string;
  hash: string;
  size: number;
  type: string;
  accessList: string[];
}

const EMRManagement: React.FC = () => {
  const [api, setApi] = useState<ApiPromise | null>(null);
  const [emrs, setEmrs] = useState<EMR[]>([]);
  const [file, setFile] = useState<File | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [accounts, setAccounts] = useState<any[]>([]);
  const [selectedAccount, setSelectedAccount] = useState<any>(null);
  
  // Initialize API connection
  useEffect(() => {
    const connect = async () => {
      try {
        // Connect to node
        const wsProvider = new WsProvider('wss://your-node-endpoint');
        const api = await ApiPromise.create({ provider: wsProvider });
        setApi(api);
        
        // Load web3 extension
        await web3Enable('Web3EMR');
        
        // Load accounts
        const allAccounts = await web3Accounts();
        setAccounts(allAccounts);
        
        if (allAccounts.length > 0) {
          setSelectedAccount(allAccounts[0]);
          await fetchEMRs(allAccounts[0]);
        }
        
        setIsConnected(true);
      } catch (error) {
        console.error('Error connecting to node:', error);
      }
    };
    
    connect();
    
    return () => {
      api?.disconnect();
    };
  }, []);
  
  const fetchEMRs = useCallback(async (account: any) => {
    if (!api) return;
    
    try {
      // Fetch EMR hashes from blockchain
      const emrHashes = await api.query.emrPallet.emrHashes(account.address);
      
      // Process EMR hashes and fetch metadata
      const processedEmrs = await Promise.all(
        emrHashes.map(async (hash: any) => {
          // Fetch EMR metadata from StorageHub or local cache
          const metadata = await fetchEMRMetadata(hash);
          return {
            id: hash.toString(),
            name: metadata.name,
            date: metadata.date,
            hash: hash.toString(),
            size: metadata.size,
            type: metadata.type,
            accessList: metadata.accessList || []
          };
        })
      );
      
      setEmrs(processedEmrs);
    } catch (error) {
      console.error('Error fetching EMRs:', error);
    }
  }, [api]);
  };
  
  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files && event.target.files[0]) {
      setFile(event.target.files[0]);
    }
  };
  
  const uploadEMR = async () => {
    if (!file || !api || !currentAccount) return;
    
    // Encrypt and upload file to StorageHub
    // Implementation details
    
    // Store hash on blockchain
    const injector = await web3FromSource(currentAccount.meta.source);
    
    api.tx.emrPallet
      .storeEmr(/* EMR hash */)
      .signAndSend(currentAccount.address, { signer: injector.signer }, (result) => {
        // Handle transaction result
      });
  };
  
  return (
    <div className="emr-management">
      <h2>My Medical Records</h2>
      
      <div className="upload-section">
        <input type="file" onChange={handleFileChange} />
        <button onClick={uploadEMR} disabled={!file}>Upload Medical Record</button>
      </div>
      
      <div className="emr-list">
        {emrs.map(emr => (
          <div key={emr.id} className="emr-item">
            <h3>{emr.name}</h3>
            <p>Date: {emr.date}</p>
            <button>View</button>
            <button>Share</button>
          </div>
        ))}
      </div>
    </div>
  );
};

export default EMRManagement;
```

# Test Strategy:
1. Unit Testing
   - Test React components in isolation with Jest and React Testing Library
   - Test custom hooks for data fetching and state management
   - Test utility functions and form validation

2. Integration Testing
   - Test component interactions
   - Verify wallet connection and account management flows
   - Test EMR upload and retrieval workflows
   - Validate access control implementation

3. End-to-End Testing
   - Test complete user flows with Cypress
   - Verify cross-browser compatibility
   - Test with different wallet extensions

4. Performance Testing
   - Measure load times for large EMR datasets
   - Test with slow network conditions
   - Verify memory usage with large file uploads

5. Security Testing
   - Test for XSS and other web vulnerabilities
   - Verify secure handling of private keys
   - Test session management and token handling

6. Accessibility Testing
   - WCAG 2.1 AA compliance
   - Keyboard navigation
   - Screen reader compatibility

7. Offline Testing
   - Test service worker functionality
   - Verify data synchronization when back online
   - Test error handling for offline operations
