# Task ID: 6
# Title: Implement Access Control and Permission Management
# Status: pending
# Dependencies: 2, 3
# Priority: high
# Description: Develop the granular access control system that allows patients to manage permissions for their EMRs.
# Details:
1. Extend EMR pallet with detailed permission levels (read, write, time-limited access)
2. Implement permission management functions in the blockchain runtime
3. Create access revocation mechanisms with immediate effect
4. Develop permission verification for EMR access requests
5. Implement audit logging for all permission changes
6. Create UI components for permission management

Pseudo-code for access control implementation:
```rust
// In emr_pallet/src/lib.rs

#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo)]
pub enum AccessLevel {
    Read,
    Write,
    TimeLimited {
        level: Box<AccessLevel>,
        expiry: BlockNumber,
    },
}

#[pallet::storage]
pub type AccessLists<T: Config> = StorageDoubleMap<
    _,
    Blake2_128Concat, EMRHash,
    Blake2_128Concat, T::AccountId,
    AccessDetails<T::BlockNumber>,
>;

#[pallet::call]
impl<T: Config> Pallet<T> {
    #[pallet::weight(T::WeightInfo::grant_access())]
    pub fn grant_access(
        origin: OriginFor<T>,
        emr_hash: EMRHash,
        grantee: T::AccountId,
        level: AccessLevel,
    ) -> DispatchResult {
        let owner = ensure_signed(origin)?;
        
        // Ensure caller is the EMR owner
        Self::ensure_emr_owner(&owner, &emr_hash)?;
        
        // Grant access
        AccessLists::<T>::insert(&emr_hash, &grantee, AccessDetails {
            level,
            granted_at: <frame_system::Pallet<T>>::block_number(),
        });
        
        // Log access grant
        Self::record_access_change(emr_hash.clone(), grantee.clone(), AccessChangeType::Granted);
        
        // Emit event
        Self::deposit_event(Event::AccessGranted(owner, grantee, emr_hash, level));
        
        Ok(())
    }
    
    #[pallet::weight(T::WeightInfo::revoke_access())]
    pub fn revoke_access(
        origin: OriginFor<T>,
        emr_hash: EMRHash,
        revokee: T::AccountId,
    ) -> DispatchResult {
        let owner = ensure_signed(origin)?;
        
        // Ensure caller is the EMR owner
        Self::ensure_emr_owner(&owner, &emr_hash)?;
        
        // Revoke access
        AccessLists::<T>::remove(&emr_hash, &revokee);
        
        // Log access revocation
        Self::record_access_change(emr_hash.clone(), revokee.clone(), AccessChangeType::Revoked);
        
        // Emit event
        Self::deposit_event(Event::AccessRevoked(owner, revokee, emr_hash));
        
        Ok(())
    }
    
    // Additional access control functions
}

impl<T: Config> Pallet<T> {
    pub fn verify_access(emr_hash: &EMRHash, account: &T::AccountId) -> Result<AccessLevel, DispatchError> {
        // Check if account is the owner
        if Self::is_emr_owner(account, emr_hash) {
            return Ok(AccessLevel::Write);
        }
        
        // Check access list
        if let Some(access_details) = AccessLists::<T>::get(emr_hash, account) {
            match access_details.level {
                AccessLevel::TimeLimited { level, expiry } => {
                    let current_block = <frame_system::Pallet<T>>::block_number();
                    if current_block <= expiry {
                        return Ok(*level);
                    } else {
                        return Err(Error::<T>::AccessExpired.into());
                    }
                },
                level => return Ok(level),
            }
        }
        
        Err(Error::<T>::NoAccess.into())
    }
    
    // Helper functions
}
```

# Test Strategy:
1. Unit tests for all access control functions
2. Test granting and revoking access with different permission levels
3. Verify immediate effect of access revocation
4. Test time-limited access expiration
5. Verify audit logging for all permission changes
6. Test access verification for various scenarios
7. Performance testing for access control operations
8. Security testing to ensure permissions cannot be bypassed
